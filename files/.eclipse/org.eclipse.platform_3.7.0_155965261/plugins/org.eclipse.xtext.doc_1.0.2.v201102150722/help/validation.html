<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Validation</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator">
<link rel="home" href="index.html" title="Xtext User Guide">
<link rel="up" href="RuntimeConcepts.html" title="Runtime Concepts">
<link rel="prev" href="Logging.html" title="Logging">
<link rel="next" href="linking.html" title="Linking">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Validation</h1>
<p>Static analysis or validation is one of the most interesting aspects when developing a programming language. The users of your languages will be grateful
				if they get informative feedback as they type. 
				In Xtext there are basically three different kinds of validation.</p>
<div class="section" title="Automatic Validation">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="AutomaticValidation"></a>Automatic Validation</h3>
</div>
</div>
</div>
<p>Some implementation aspects (e.g. the grammar, scoping) of a language have an impact on what is required for a document or semantic model to be valid. Xtext automatically takes care of this. </p>
<div class="section" title="Lexer/Parser: Syntactical Validation">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="syntactical_validation"></a>Lexer/Parser: Syntactical Validation</h4>
</div>
</div>
</div>
<p>The syntactical correctness of any textual input is validated automatically by the parser. The error messages are generated by the underlying parser technology.
						One can use the 
						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parser/antlr/ISyntaxErrorMessageProvider.java?root=Modeling_Project&view=co" target="_new">ISyntaxErrorMessageProvider</a>-API to customize this messages.
						Any syntax errors can be retrieved from the Resource using the common EMF API:
					</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<span class="emphasis"><em>org.eclipse.emf.ecore.resource.Resource.getErrors()</em></span>
							
</p>
</li>
<li class="listitem">
<p>
								
<span class="emphasis"><em>org.eclipse.emf.ecore.resource.Resource.getWarnings()</em></span>
							
</p>
</li>
</ul>
</div>
</div>
<div class="section" title="Linker: Crosslink Validation">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="linking_validation"></a>Linker: Crosslink Validation</h4>
</div>
</div>
</div>
<p>Any broken crosslinks can be checked generically. As crosslink resolution is done lazily (see 
						<a class="link" href="linking.html" title="Linking">linking</a>), any broken links are resolved lazily as well.
						If you want to validate whether all links are valid, you will have to navigate through the model so that all installed EMF proxies get resolved. This is done automatically in the editor.
					</p>
<p>Similar to syntax errors, any unresolvable crosslinks will be reported and can be obtained through:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<span class="emphasis"><em>org.eclipse.emf.ecore.resource.Resource.getErrors()</em></span>
							
</p>
</li>
<li class="listitem">
<p>
								
<span class="emphasis"><em>org.eclipse.emf.ecore.resource.Resource.getWarnings()</em></span>
							
</p>
</li>
</ul>
</div>
</div>
<div class="section" title="Serializer: Concrete Syntax Validation">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="concrete_syntax_validation"></a>Serializer: Concrete Syntax Validation</h4>
</div>
</div>
</div>
<p>The 
						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/IConcreteSyntaxValidator.java?root=Modeling_Project&view=co" target="_new">IConcreteSyntaxValidator</a> validates all constraints that are implied by a grammar. Meeting these constraints for a model is mandatory to be serialized.
					</p>
<p>Example:</p>
<div class="literallayout">
<p>
<code class="code">MyRule:<br>
&nbsp;&nbsp;({MySubRule}&nbsp;"sub")?&nbsp;(strVal+=ID&nbsp;intVal+=INT)*;<br>
	
<br>

</code>
</p>
</div>
<p>This implies several constraints:</p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>Types: only instances of 
								<span class="emphasis"><em>MyRule</em></span> and 
								<span class="emphasis"><em>MySubRule</em></span> are allowed for this rule. Sub-types are prohibited, since the parser never instantiates unknown sub-types.
							</p>
</li>
<li class="listitem">
<p>Features: In case the 
								<span class="emphasis"><em>MyRule</em></span> and 
								<span class="emphasis"><em>MySubRule</em></span> have 
								<span class="emphasis"><em>EStructuralFeatures</em></span> besides 
								<span class="emphasis"><em>strVal</em></span> and 
								<span class="emphasis"><em>intVal</em></span>, only 
								<span class="emphasis"><em>strVal</em></span> and 
								<span class="emphasis"><em>intVal</em></span> may have 
								<a class="link" href="serialization.html#transientvalues" title="Transient Values">non-transient values</a>.
							</p>
</li>
<li class="listitem">
<p>Quantities: The following condition must be true: 
								<span class="emphasis"><em>strVal.size() == intVal.size()</em></span>.
							</p>
</li>
<li class="listitem">
<p>Values: It must be possible to 
								<a class="link" href="valueconverter.html" title="Value Converter">convert all values</a> to valid tokens for terminal rule 
								<span class="emphasis"><em>STRING</em></span>.  The same is true for 
								<span class="emphasis"><em>intVal</em></span> and 
								<span class="emphasis"><em>INT</em></span>.
							</p>
</li>
</ol>
</div>
<p>The typical use cases for the concrete syntax validator are validation in non-Xtext-editors that, however, use an 
						<span class="emphasis"><em>XtextResource</em></span>. This is, for example, the case when combining GMF and Xtext. Another use case is when the semantic model is modified &ldquo;manually&rdquo; (not by the parser) and then serialized again. Since it is very difficult for the serializer to provide 
						<a class="link" href="serialization.html#parsetreeconstructor" title="Parse Tree Constructor">meaningful error messages</a>, the concrete syntax validator is executed by default before serialization. A textual Xtext editor itself, however, is 
						<span class="emphasis"><em>not</em></span> a valid use case. Here, the parser ensures that all syntactical constraints are met. Therefore, there is no value in additionally running the concrete syntax validator.  
					</p>
<p>There are some limitations to the concrete syntax validator which result from the fact that it treats the grammar as declarative, which is something the parser doesn&rsquo;t always do.</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>Grammar rules containing assigned actions (e.g. 
								<span class="emphasis"><em>{MyType.myFeature=current}</em></span> are ignored. Unassigned actions (e.g. 
								<span class="emphasis"><em>{MyType}</em></span>), however, are supported. 
							</p>
</li>
<li class="listitem">
<p>Grammar rules that delegate to one or more rules containing assigned actions via unassigned rule calls are ignored.</p>
</li>
<li class="listitem">
<p>Orders within list-features can not be validated. e.g. 
								<span class="emphasis"><em>Rule: (foo+=R1 foo+=R2)*</em></span> implies that 
								<span class="emphasis"><em>foo</em></span> is expected to contain instances of 
								<span class="emphasis"><em>R1</em></span> and 
								<span class="emphasis"><em>R2</em></span> in an alternating order. 
							</p>
</li>
</ul>
</div>
<p>To use concrete syntax validation you can let Guice inject an instance of 

						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/IConcreteSyntaxValidator.java?root=Modeling_Project&view=co" target="_new">IConcreteSyntaxValidator</a> and use it directly. 
						Furthermore, there is an adapter (
						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/impl/ConcreteSyntaxEValidator.java?root=Modeling_Project&view=co" target="_new">ConcreteSyntaxEValidator</a>) 
						allows integrating of the concrete syntax validator as an 
						<span class="emphasis"><em>EValidator</em></span>. You can, for example, enable it in 
						your runtime module, by adding:
					</p>
<div class="literallayout">
<p>
<code class="code">@SingletonBinding(eager&nbsp;=&nbsp;true)<br>
public&nbsp;Class&lt;?&nbsp;extends&nbsp;ConcreteSyntaxEValidator&gt;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bindConcreteSyntaxEValidator()&nbsp;{<br>
&nbsp;&nbsp;return&nbsp;ConcreteSyntaxEValidator.class;<br>
}<br>

</code>
</p>
</div>
<p>To customize error messages please see 

						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/IConcreteSyntaxDiagnosticProvider.java?root=Modeling_Project&view=co" target="_new">IConcreteSyntaxDiagnosticProvider</a> and subclass 

						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/impl/ConcreteSyntaxDiagnosticProvider.java?root=Modeling_Project&view=co" target="_new">ConcreteSyntaxDiagnosticProvider</a>.
					</p>
</div>
</div>
<div class="section" title="Custom Validation">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="custom_validation"></a>Custom Validation</h3>
</div>
</div>
</div>
<p>In addition to the afore mentioned kinds of validation, which are more or less done automatically, you can specify additional constraints specific for your Ecore model.
					We leverage existing EMF API (mainly 
					<span class="emphasis"><em>EValidator</em></span>) and have put some convenience stuff on top. 
					Basically all you need to do is to make sure that an 
					<span class="emphasis"><em>EValidator</em></span> is registered for your 
					<span class="emphasis"><em>EPackage</em></span>. The registry for 
					<span class="emphasis"><em>EValidators</em></span> (
					<span class="emphasis"><em>EValidator.Registry.INSTANCE</em></span>) can only be filled programmatically.
					That means contrary to the EPackage and 
					<span class="emphasis"><em>Resource.Factory</em></span> registries there is no Equinox extension point to populate the validator registry.
				</p>
<p>For Xtext we provide a 
					<a class="link" href="configuration.html#generator_fragment" title="Generator Fragments">generator fragment</a> for the convenient Java-based 
					<span class="emphasis"><em>EValidator</em></span> API. Just add the following fragment to your generator configuration and you are good to go:
				</p>
<div class="literallayout">
<p>
<code class="code">fragment&nbsp;=&nbsp;org.eclipse.xtext.generator.validation.JavaValidatorFragment&nbsp;{}<br>

<br>

</code>
</p>
</div>
<p>The generator will provide you with two Java classes. An abstract class generated to 
					<span class="emphasis"><em>src-gen/</em></span> which extends the library class 
					<span class="emphasis"><em>AbstractDeclarativeValidator</em></span>. This one just registers the EPackages for which this validator introduces constraints.
					The other class is a subclass of that abstract class and is generated to the 
					<span class="emphasis"><em>src/</em></span> folder in order to be edited by you. That&rsquo;s where you put the constraints in.
				</p>
<p>The purpose of the 
					<span class="emphasis"><em>AbstractDeclarativeValidator</em></span> is to allow you to write constraints in a declarative way &ndash; as the class name already suggests. That is instead of writing exhaustive if-else constructs or extending the generated EMF switch you just have to add the 
					<span class="emphasis"><em>@Check</em></span> annotation to any method and it will be invoked automatically when validation takes place.
					Moreover you can state for what type the respective constraint method is, just by declaring a typed parameter. This also lets you avoid any type casts.  
					In addition to the reflective invocation of validation methods the 
					<span class="emphasis"><em>AbstractDeclarativeValidator</em></span> provides a couple of convenient assertions.
				</p>
<p>All in all this is very similar to how JUnit works. Here is an example:</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;class&nbsp;DomainmodelJavaValidator&nbsp;<br>
&nbsp;&nbsp;extends&nbsp;AbstractDomainmodelJavaValidator&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;@Check<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;checkTypeNameStartsWithCapital(Type&nbsp;type)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!Character.isUpperCase(type.getName().charAt(0)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;warning("Name&nbsp;should&nbsp;start&nbsp;with&nbsp;a&nbsp;capital",&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DomainmodelPackage.TYPE__NAME);<br>
&nbsp;&nbsp;}<br>
}<br>

<br>

</code>
</p>
</div>
<p>You can also implement quick fixes for individual validation errors and warnings. See the 
					<a class="link" href="quickfixes.html" title="Quick Fixes">chapter on quick fixes</a> for details.
				</p>
</div>
<div class="section" title="Validation with the Check Language">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="check_based_validation"></a>Validation with the Check Language</h3>
</div>
</div>
</div>
<p>In addition to the Java-based validation code you can use the language Check (from M2T/Xpand) to implement constraint checks against your model. To do so, you have to configure the 
					<a class="link" href="configuration.html#generator" title="The Generator">generator</a> with the

					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/validation/CheckFragment.java?root=Modeling_Project&view=co" target="_new">CheckFragment</a>.
					Please note, that you can combine both types of validation in your project. 
				</p>
<div class="literallayout">
<p>
<code class="code">fragment&nbsp;=&nbsp;org.eclipse.xtext.generator.validation.CheckFragment&nbsp;{}<br>
&nbsp;&nbsp;<br>

</code>
</p>
</div>
<p>After regenerating your language artifacts you will find three new files &ldquo;YourLanguageChecks.chk&rdquo;, &ldquo;YourLanguageFastChecks.chk&rdquo; and &ldquo;YourLanguageExpensiveChecks.chk&rdquo; in the 
					<span class="emphasis"><em>src/</em></span> folder in the sub-package 
					<span class="emphasis"><em>validation</em></span>.  The checks in these files will be executed when saving a file, while typing (FastChecks) or when triggering the validation explicitly (ExpensiveChecks). When using Check the example of the previous chapter could be written like this.
				</p>
<div class="literallayout">
<p>
<code class="code">context&nbsp;Type#name&nbsp;WARNING&nbsp;"Name&nbsp;should&nbsp;start&nbsp;with&nbsp;a&nbsp;capital":<br>
&nbsp;&nbsp;name.toFirstUpper()&nbsp;==&nbsp;name;&nbsp;&nbsp;<br>

<br>

</code>
</p>
</div>
<p>Each check works in a specific context (here: 
					<span class="emphasis"><em>Type</em></span>) and can further denote a feature to which a warning or error should be attached to (here: 
					<span class="emphasis"><em>name</em></span>). Each check could either be a 
					<span class="emphasis"><em>WARNING</em></span> or an 
					<span class="emphasis"><em>ERROR</em></span> with a given string to explain the situation. The essential part of each check is an invariant that must hold true for the given context. If it fails the check will produce an issue with the provided explanation.
				</p>Please read more about the Check language as well as the underlying expression language in Xpand&rsquo;s reference documentation which is shipped as Eclipse help. 
			</div>
<div class="section" title="Validating Manually">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="ValidatingManually"></a>Validating Manually</h3>
</div>
</div>
</div>
<p>As noted above, Xtext uses EMF&rsquo;s 
					<span class="emphasis"><em>EValidator</em></span> API to register Java or Check validators. You can run the validators on your model programmatically using EMF&rsquo;s 
					<span class="emphasis"><em>Diagnostician</em></span>, e.g.
				</p>
<div class="literallayout">
<p>
<code class="code">EObject&nbsp;myModel&nbsp;=&nbsp;myResource.getContents().get(0);<br>
Diagnostic&nbsp;diagnostic&nbsp;=&nbsp;Diagnostician.INSTANCE.validate(myModel);<br>
switch&nbsp;(diagnostic.getSeverity())&nbsp;{<br>
&nbsp;&nbsp;case&nbsp;Diagnostic.ERROR:<br>
&nbsp;&nbsp;&nbsp;&nbsp;System.err.println("Model&nbsp;has&nbsp;errors:&nbsp;",diagnostic);<br>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;case&nbsp;Diagnostic.WARNING:<br>
&nbsp;&nbsp;&nbsp;&nbsp;System.err.println("Model&nbsp;has&nbsp;warnings:&nbsp;",diagnostic);<br>
}<br>

<br>

</code>
</p>
</div>
</div>
<div class="section" title="Test Validators">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="test_validators"></a>Test Validators</h3>
</div>
</div>
</div>
<p>If you have implemented your validators by extending 
					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/AbstractDeclarativeValidator.java?root=Modeling_Project&view=co" target="_new">AbstractDeclarativeValidator</a>, there are helper classes which may assist you when testing your validators.
				</p>
<p>Testing validators typically works as follows: </p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>The test creates some models which intentionally violate some constraints.</p>
</li>
<li class="listitem">
<p>The test runs some choosen @Check-methods from the validator.</p>
</li>
<li class="listitem">
<p>The test asserts whether the @Check-methods have raised the expected warnings and errors.</p>
</li>
</ol>
</div>
<p>To create models, you can either use EMF&rsquo;s 
					<span class="emphasis"><em>ResourceSet</em></span> to load models from your hard disk or you can utilize the 
					<span class="emphasis"><em>Factory</em></span> (which EMF generates for each 
					<span class="emphasis"><em>EPackage</em></span>) to construct the needed model elements manually. While the fist option has the advantages that you can edit your models in your textual concrete syntax, the second option has the advantage that you can create partial models.
				</p>
<p>To run the @Check-methods and ensure they raise the intended errors and warnings, you can utilize 
					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/ValidatorTester.java?root=Modeling_Project&view=co" target="_new">ValidatorTester</a> as shown by the following example:
				</p>
<p>Validator:</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;class&nbsp;MyLanguageValidator&nbsp;extends&nbsp;AbstractDeclarativeValidator&nbsp;{<br>
&nbsp;&nbsp;@Check<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;checkFooElement(FooElement&nbsp;element)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;if(element.getBarAttribute().contains("foo"))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error("Only&nbsp;Foos&nbsp;allowed",&nbsp;element,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyLanguagePackage.FOO_ELEMENT__BAR_ATTRIBUTE,&nbsp;101);<br>
&nbsp;&nbsp;}<br>
}<br>

<br>

</code>
</p>
</div>
<p>JUnit-Test:</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;class&nbsp;MyLanguageValidatorTest&nbsp;extends&nbsp;AbstractXtextTests&nbsp;{<br>

<br>
&nbsp;&nbsp;private&nbsp;ValidatorTester&lt;MyLanguageValidator&gt;&nbsp;tester;<br>

<br>
&nbsp;&nbsp;@Override<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;setUp()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;with(MyLanguageStandaloneSetup.class);<br>
&nbsp;&nbsp;&nbsp;&nbsp;MyLanguageValidator&nbsp;validator&nbsp;=&nbsp;get(MyLanguageValidator.class);<br>
&nbsp;&nbsp;&nbsp;&nbsp;tester&nbsp;=&nbsp;new&nbsp;ValidatorTester&lt;TestingValidator&gt;(validator);<br>
&nbsp;&nbsp;}<br>

<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;testError()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;FooElement&nbsp;model&nbsp;=&nbsp;MyLanguageFactory.eINSTANCE.createFooElement()<br>
&nbsp;&nbsp;&nbsp;&nbsp;model.setBarAttribute("barbarbarbarfoo");<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;tester.validator().checkFooElement(model);<br>
&nbsp;&nbsp;&nbsp;&nbsp;tester.diagnose().assertError(101);<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;testError2()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;FooElement&nbsp;model&nbsp;=&nbsp;MyLanguageFactory.eINSTANCE.createFooElement()<br>
&nbsp;&nbsp;&nbsp;&nbsp;model.setBarAttribute("barbarbarbarfoo");<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;tester.validate(model).assertError(101);<br>
&nbsp;&nbsp;}<br>
}<br>

<br>

</code>
</p>
</div>
<p>This example uses JUnit 3, but since the involved classes from Xtext have no dependency on JUnit 
					whatsoever, JUnit 4 and other testing frameworks will work as well.  JUnit runs the 
					<span class="emphasis"><em>setUp()</em></span>-method 
					before each testcase and thereby helps to create some common state. In this example, the validator 
					(
					<span class="emphasis"><em>MyLanguageValidator</em></span>) is instantiated by means of Google Guice. As we inherit from the 
					<span class="emphasis"><em>AbstractXtextTests</em></span>
					there are a plenty of useful methods available and the state of the global EMF singletons will be restored in the

					<span class="emphasis"><em>tearDown()</em></span>. 
					Afterwards, the 
					<span class="emphasis"><em>ValidatorTester</em></span> is created and parameterized with the actual validator. It acts as 
					a wrapper for the validator, ensures that the validator has a valid state and provides convenient 
					access to the validator itself (
					<span class="emphasis"><em>tester.validator()</em></span>) as well as to the utility classes which 
					assert diagnostics created by the validator (
					<span class="emphasis"><em>tester.diagnose()</em></span>). Please be aware that you have to 
					call 
					<span class="emphasis"><em>validator()</em></span> before you can call 
					<span class="emphasis"><em>diagnose()</em></span>. However, you can call 
					<span class="emphasis"><em>validator()</em></span> multiple 
					times in a row.
				</p>
<p>While 
					<span class="emphasis"><em>validator()</em></span> allows to call the validator&rsquo;s @Check-methods directly, 
					<span class="emphasis"><em>validate(model)</em></span> leaves it 
					to the framework to call the applicable @Check-methods. However, to avoid side-effects between tests, 
					it is recommended to call the @Check-methods directly.
				</p>
<p>
					
<span class="emphasis"><em>diagnose()</em></span> and 
					<span class="emphasis"><em>validate(model)</em></span> return an object of type 

					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.junit/src/org/eclipse/xtext/junit/validation/AssertableDiagnostics.java?root=Modeling_Project&view=co" target="_new">AssertableDiagnostics</a> which provides 
					several 
					<span class="emphasis"><em>assert</em></span>-methods to verify whether the expected diagnostics are present:
				</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<span class="emphasis"><em>assertError(int code)</em></span>: There must be one diagnostic with severity ERROR and the supplied error code.
						</p>
</li>
<li class="listitem">
<p>
							
<span class="emphasis"><em>assertErrorContains(String messageFragment)</em></span>:  There must be one diagnostic with severity ERROR and its message must contain 
							<span class="emphasis"><em>messageFragment</em></span>.
						</p>
</li>
<li class="listitem">
<p>
							
<span class="emphasis"><em>assertError(int code, String messageFragment)</em></span>: Verifies severity, error code and messageFragment.
						</p>
</li>
<li class="listitem">
<p>
							
<span class="emphasis"><em>assertWarning(...)</em></span>: This method is available for the same combination of parameters as 
							<span class="emphasis"><em>assertError()</em></span>.
						</p>
</li>
<li class="listitem">
<p>
							
<span class="emphasis"><em>assertOK()</em></span>: Expects that no diagnostics (errors, warnings etc.) have been raised.   
						</p>
</li>
<li class="listitem">
<p>
							
<span class="emphasis"><em>assertDiagnostics(int severity, int code, String messageFragment)</em></span>: Verifies severity, error code and messageFragment.
						</p>
</li>
<li class="listitem">
<p>
							
<span class="emphasis"><em>assertAll(DiagnosticPredicate... predicates)</em></span>: Allows to describe multiple diagnostics at the same time and verifies that all of them are present. Class 
							<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/AssertableDiagnostics.java?root=Modeling_Project&view=co" target="_new">AssertableDiagnostics</a> contains static 
							<span class="emphasis"><em>error()</em></span> and 
							<span class="emphasis"><em>warning()</em></span>-methods which help to create the needed 
							<span class="emphasis"><em>DiagnosticPredicate</em></span>. Example: 
							<span class="emphasis"><em>assertAll(error(123), warning(&ldquo;some part of the message&rdquo;))</em></span>. 
						</p>
</li>
<li class="listitem">
<p>
							
<span class="emphasis"><em>assertAny(DiagnosticPredicate predicate)</em></span>: Asserts that a diagnostic exists which matches the predicate. 
						</p>
</li>
</ul>
</div>
</div>
</body>
</html>
