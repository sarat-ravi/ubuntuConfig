<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Formatting (Pretty Printing)</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator">
<link rel="home" href="index.html" title="Xtext User Guide">
<link rel="up" href="RuntimeConcepts.html" title="Runtime Concepts">
<link rel="prev" href="serialization.html" title="Serialization">
<link rel="next" href="encoding.html" title="Encoding in Xtext">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Formatting (Pretty Printing)</h1>
<p>A formatter can be implemented via the 
				<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/IFormatter.java?root=Modeling_Project&view=co" target="_new">IFormatter</a> 
				service. Technically speaking, a formatter is a 
				<a class="link" href="serialization.html#tokenstream" title="Token Stream">Token Stream</a> which 
				inserts/removes/modifies hidden tokens (whitespace, line-breaks, comments).
			</p>
<p>The formatter is invoked during the 
				<a class="link" href="serialization.html" title="Serialization">serialization phase</a> and when the user triggers 
				formatting in the editor (for example, using the CTRL+SHIFT+F shortcut).
			</p>
<p>Xtext ships with two formatters:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>The 
						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/OneWhitespaceFormatter.java?root=Modeling_Project&view=co" target="_new">OneWhitespaceFormatter</a> simply writes one whitespace between all tokens.
					</p>
</li>
<li class="listitem">
<p>The 
						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/AbstractDeclarativeFormatter.java?root=Modeling_Project&view=co" target="_new">AbstractDeclarativeFormatter</a> allows advanced configuration using a 
						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/FormattingConfig.java?root=Modeling_Project&view=co" target="_new">FormattingConfig</a>. Both are explained in the 
						<a class="link" href="formatting.html#declarativeformatter" title="Declarative Formatter">next chapter</a>.
					</p>
</li>
</ul>
</div>
<div class="section" title="Declarative Formatter">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="declarativeformatter"></a>Declarative Formatter</h3>
</div>
</div>
</div>
<p>A declarative formatter can be implemented by sub-classing 

					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/AbstractDeclarativeFormatter.java?root=Modeling_Project&view=co" target="_new">AbstractDeclarativeFormatter</a>, as shown in 
					the following example:
				</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;class&nbsp;ExampleFormatter&nbsp;extends&nbsp;AbstractDeclarativeFormatter&nbsp;{<br>

<br>
&nbsp;&nbsp;@Override<br>
&nbsp;&nbsp;protected&nbsp;void&nbsp;configureFormatting(FormattingConfig&nbsp;c)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;ExampleLanguageGrammarAccess&nbsp;f&nbsp;=&nbsp;getGrammarAccess();<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;c.setAutoLinewrap(120);<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;find&nbsp;common&nbsp;keywords&nbsp;an&nbsp;specify&nbsp;formatting&nbsp;for&nbsp;them<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Pair&lt;Keyword,&nbsp;Keyword&gt;&nbsp;pair&nbsp;:&nbsp;f.findKeywordPairs("(",&nbsp;")"))&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.setNoSpace().after(pair.getFirst());<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.setNoSpace().before(pair.getSecond());<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Keyword&nbsp;comma&nbsp;:&nbsp;f.findKeywords(","))&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.setNoSpace().before(comma);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>

<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;formatting&nbsp;for&nbsp;grammar&nbsp;rule&nbsp;Line<br>
&nbsp;&nbsp;&nbsp;&nbsp;c.setLinewrap(2).after(f.getLineAccess().getSemicolonKeyword_1());<br>
&nbsp;&nbsp;&nbsp;&nbsp;c.setNoSpace().before(f.getLineAccess().getSemicolonKeyword_1());<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;formatting&nbsp;for&nbsp;grammar&nbsp;rule&nbsp;TestIndentation<br>
&nbsp;&nbsp;&nbsp;&nbsp;c.setIndentationIncrement().after(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.getTestIndentationAccess().getLeftCurlyBracketKeyword_1());<br>
&nbsp;&nbsp;&nbsp;&nbsp;c.setIndentationDecrement().before(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.getTestIndentationAccess().getRightCurlyBracketKeyword_3());<br>
&nbsp;&nbsp;&nbsp;&nbsp;c.setLinewrap().after(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.getTestIndentationAccess().getLeftCurlyBracketKeyword_1());<br>
&nbsp;&nbsp;&nbsp;&nbsp;c.setLinewrap().after(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.getTestIndentationAccess().getRightCurlyBracketKeyword_3());<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;formatting&nbsp;for&nbsp;grammar&nbsp;rule&nbsp;Param<br>
&nbsp;&nbsp;&nbsp;&nbsp;c.setNoLinewrap().around(f.getParamAccess().getColonKeyword_1());<br>
&nbsp;&nbsp;&nbsp;&nbsp;c.setNoSpace().around(f.getParamAccess().getColonKeyword_1());<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;formatting&nbsp;for&nbsp;Comments&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;cfg.setLinewrap(0,&nbsp;1,&nbsp;2).before(g.getSL_COMMENTRule());<br>
&nbsp;&nbsp;&nbsp;&nbsp;cfg.setLinewrap(0,&nbsp;1,&nbsp;2).before(g.getML_COMMENTRule());<br>
&nbsp;&nbsp;&nbsp;&nbsp;cfg.setLinewrap(0,&nbsp;1,&nbsp;1).after(g.getML_COMMENTRule());<br>
&nbsp;&nbsp;}<br>
}<br>

<br>

</code>
</p>
</div>
<p>The formatter has to implement the method 
					<span class="emphasis"><em>configureFormatting(...)</em></span> which declaratively sets up 
					a 
					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/FormattingConfig.java?root=Modeling_Project&view=co" target="_new">FormattingConfig</a>.
				</p>
<p>The 
					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/FormattingConfig.java?root=Modeling_Project&view=co" target="_new">FormattingConfig</a> consist of general 
					settings and a set of formatting instructions:
				</p>
<div class="section" title="General FormattingConfig Settings">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="GeneralFormattingConfigSettings"></a>General FormattingConfig Settings</h4>
</div>
</div>
</div>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<span class="emphasis"><em>setAutoLinewrap(int)</em></span> defines the amount of characters after which a line-break should be dynamically inserted between two tokens. The instructions 
								<span class="emphasis"><em>setNoLinewrap().???()</em></span>,  
								<span class="emphasis"><em>setNoSpace().???()</em></span> and 
								<span class="emphasis"><em>setSpace(space).???()</em></span> suppress this behavior locally. The default is 80.
							</p>
</li>
</ul>
</div>
</div>
<div class="section" title="FormattingConfig Instructions">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="FormattingConfigInstructions"></a>FormattingConfig Instructions</h4>
</div>
</div>
</div>
<p>Per default, the 
						<a class="link" href="formatting.html#declarativeformatter" title="Declarative Formatter">declarative formatter</a> inserts one whitespace between two 
						tokens. Instructions can be used to specify a different behavior. They consist of two parts: 
						<span class="emphasis"><em>When</em></span> 
						to apply the instruction and 
						<span class="emphasis"><em>what</em></span> to do.
					</p>
<p>To understand 
						<span class="emphasis"><em>when</em></span> an instruction is applied think of a stream of tokens whereas each token is 
						associated with the corresponding grammar element. The instructions are matched against these grammar 
						elements. The following matching criteria exist:
					</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<span class="emphasis"><em>after(ele)</em></span>: The instruction is applied after the grammar element 
								<span class="emphasis"><em>ele</em></span> has been matched. For example, if your grammar uses the keyword &ldquo;;&rdquo; to end lines, this can instruct the formatter to insert a line break after the semicolon.  
							</p>
</li>
<li class="listitem">
<p>
								
<span class="emphasis"><em>before(ele)</em></span>: The instruction is executed before the matched element. For example, if your grammar contains lists which separate their values with the keyword &ldquo;,&rdquo;, you can instruct the formatter to suppress the whitespace before the comma.
							</p>
</li>
<li class="listitem">
<p>
								
<span class="emphasis"><em>around(ele)</em></span>: This is the same as 
								<span class="emphasis"><em>before(ele)</em></span> combined with  
								<span class="emphasis"><em>after(ele)</em></span>.  
							</p>
</li>
<li class="listitem">
<p>
								
<span class="emphasis"><em>between(ele1, ele2)</em></span>: This matches if 
								<span class="emphasis"><em>ele2</em></span> directly follows 
								<span class="emphasis"><em>ele1</em></span> in the document. There may be no other tokens in between 
								<span class="emphasis"><em>ele1</em></span> and 
								<span class="emphasis"><em>ele2</em></span>.
							</p>
</li>
<li class="listitem">
<p>
								
<span class="emphasis"><em>bounds(ele1, ele2)</em></span>: This is the same as 
								<span class="emphasis"><em>after(ele1)</em></span> combined with  
								<span class="emphasis"><em>before(ele2)</em></span>.
							</p>
</li>
<li class="listitem">
<p>
								
<span class="emphasis"><em>range(ele1, ele2)</em></span>: The rule is enabled when 
								<span class="emphasis"><em>ele1</em></span> is matched, and disabled when 
								<span class="emphasis"><em>ele2</em></span> is matched. Thereby, the rule is active for the complete region which is surrounded by 
								<span class="emphasis"><em>ele1</em></span> and 
								<span class="emphasis"><em>ele2</em></span>.
							</p>
</li>
</ul>
</div>
<p>The term 
						<span class="emphasis"><em>tokens</em></span> is used slightly different here compared to the parser/lexer. Here, a token is a 
						keyword or the string that is matched by a terminal rule, data type rule or cross-reference. In the 
						terminology of the lexer a data type rule can match a composition of multiple tokens.
					</p>
<p>The parameter 
						<span class="emphasis"><em>ele</em></span> can be a grammar&rsquo;s 
						<span class="emphasis"><em>AbstractElement</em></span> or a grammar&rsquo;s 
						<span class="emphasis"><em>AbstractRule</em></span>. All grammar 
						rules and almost all abstract elements can be matched. This includes rule calls, parser rules, groups 
						and alternatives. The semantic of 
						<span class="emphasis"><em>before(ele)</em></span>, 
						<span class="emphasis"><em>after(ele)</em></span>, etc. for rule calls and parser rules is 
						identical to when the parser would &ldquo;pass&rdquo; this part of the grammar. The stack of called rules is taken 
						into account. The following abstract elements can 
						<span class="bold"><strong>not</strong></span> have assigned formatting instructions:
					</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>Actions. E.g. 
								<span class="emphasis"><em>{MyAction}</em></span> or 
								<span class="emphasis"><em>{MyAction.myFeature=current}</em></span>.
							</p>
</li>
<li class="listitem">
<p>Grammar elements nested in data type rules. This is due to to the fact that tokens matched by a data type rule are treated as atomic by the serializer. To format these tokens, please implement a 
								<a class="link" href="valueconverter.html" title="Value Converter">ValueConverter</a>. 
							</p>
</li>
<li class="listitem">
<p>Grammar elements nested in 
								<span class="emphasis"><em>CrossReferences</em></span>.
							</p>
</li>
</ul>
</div>
<p>After having explained how rules can be activated, this is what they can do:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<span class="emphasis"><em>setIndentationIncrement()</em></span> increments indentation by one unit at this position. Whether one unit consists of one tab-character or spaces is defined by 
								<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/IIndentationInformation.java?root=Modeling_Project&view=co" target="_new">IIndentationInformation</a>. The default implementation consults Eclipse&rsquo;s 
								<span class="emphasis"><em>PreferenceStore</em></span>.
							</p>
</li>
<li class="listitem">
<p>
								
<span class="emphasis"><em>setIndentationDecrement()</em></span> decrements indentation by one unit.
							</p>
</li>
<li class="listitem">
<p>
								
<span class="emphasis"><em>setLinewrap()</em></span>: Inserts a line-wrap at this position.
							</p>
</li>
<li class="listitem">
<p>
								
<span class="emphasis"><em>setLinewrap(int count)</em></span>: Inserts 
								<span class="emphasis"><em>count</em></span> numbers of line-wrap at this position.
							</p>
</li>
<li class="listitem">
<p>
								
<span class="emphasis"><em>setLinewrap(int min, int default, int max)</em></span>: If the amount of line-wraps that have been at this position before formatting can be determined (i.g. when a node model is present), then the amount of of line-wraps is adjusted to be within the interval [
								<span class="emphasis"><em>min</em></span>, 
								<span class="emphasis"><em>max</em></span>] and is then reused. In all other cases 
								<span class="emphasis"><em>default</em></span> line-wraps are inserted. Example: 
								<span class="emphasis"><em>setLinewrap(0, 0, 1)</em></span> will preserve existing line-wraps, but won&rsquo;t allow more than one line-wrap between two tokens.    
							</p>
</li>
<li class="listitem">
<p>
								
<span class="emphasis"><em>setNoLinewrap()</em></span>: Suppresses automatic line wrap, which may occur when the line&rsquo;s length exceeds the defined limit.
							</p>
</li>
<li class="listitem">
<p>
								
<span class="emphasis"><em>setSpace(String space)</em></span>: Inserts the string 
								<span class="emphasis"><em>space</em></span> at this position. If you use this to insert something else than whitespace, tabs or newlines, a small puppy will die somewhere in this world.
							</p>
</li>
<li class="listitem">
<p>
								
<span class="emphasis"><em>setNoSpace()</em></span>: Suppresses the whitespace between tokens at this position. Be aware that between some tokens a whitespace is required to maintain a valid concrete syntax. 
							</p>
</li>
</ul>
</div>
</div>
<div class="section" title="Grammar Element Finders">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="GrammarElementFinders"></a>Grammar Element Finders</h4>
</div>
</div>
</div>
<p>Sometimes, if a grammar contains many similar elements for which the same formatting instructions ought 
						to apply, it can be tedious to specify them for each grammar element individually. The 

						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/IGrammarAccess.java?root=Modeling_Project&view=co" target="_new">IGrammarAccess</a> provides convenience methods for this. The 
						find methods are available for the grammar and for each parser rule.
					</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<span class="emphasis"><em>findKeywords(String... keywords)</em></span> returns all keywords that equal one of the parameters.
							</p>
</li>
<li class="listitem">
<p>
								
<span class="emphasis"><em>findKeywordPairs(String leftKw, String rightKw)</em></span>: returns tuples of keywords from the same grammar rule. Pairs are matched nested and sequentially.  Example: for 
								<span class="emphasis"><em>Rule: &lsquo;(&rsquo; name=ID (&lsquo;(&rsquo; foo=ID &lsquo;)&rsquo;) &lsquo;)&rsquo; | &lsquo;(&rsquo; bar=ID ')'</em></span> 
								<span class="emphasis"><em>findKeywordPairs(&ldquo;(&rdquo;, &ldquo;)&rdquo;)</em></span> returns three pairs.
							</p>
</li>
</ul>
</div>
</div>
</div>
<div class="section" title="Fragment Provider (Referencing Xtext Models From Other EMF Artifacts)">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="fragmentProvider"></a>Fragment Provider (Referencing Xtext Models From Other EMF Artifacts)</h3>
</div>
</div>
</div>
<p>Although inter-Xtext linking is not done by URIs, you may want to be able to reference your 
					<span class="emphasis"><em>EObject</em></span> 
					from non-Xtext models. In those cases URIs are used, which are made up of a part identifying the resource 
					and a second part that points to an object. 
					Each 
					<span class="emphasis"><em>EObject</em></span> contained in a resource can be identified by a so called 
					<span class="emphasis"><em>fragment</em></span>.
				</p>
<p>A fragment is a part of an EMF URI and needs to be unique per resource.</p>
<p>The generic resource shipped with EMF provides a generic path-like computation of fragments. These 
					fragment paths are unique by default and do not have to be serialized. On the other hand, they can be 
					easily broken by reordering the elements in a resource. </p>
<p>With an XMI or other binary-like serialization it is also common and possible to use UUIDs. UUIDs 
					are usually binary and technical, so you don&rsquo;t want them in human readable representations.</p>
<p>However with a textual concrete syntax we want to be able to compute fragments out of the human readable 
					information. We don&rsquo;t want to force people to use UUIDs (i.e. synthetic identifiers) or fragile, relative, generic 
					paths in order to refer to 
					<span class="emphasis"><em>EObjects</em></span>.
				</p>
<p>Therefore one can contribute a so called 
					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IFragmentProvider.java?root=Modeling_Project&view=co" target="_new">IFragmentProvider</a> 
					per language. It has two methods: 
					<span class="emphasis"><em>getFragment(EObject, Fallback)</em></span> to calculate the fragment of an 

					<span class="emphasis"><em>EObject</em></span> and 
					<span class="emphasis"><em>getEObject(Resource, String, Fallback)</em></span> to go the opposite direction. The 
					<span class="emphasis"><em>Fallback</em></span> 
					interface allows to delegate to the default strategy &ndash; usually the fragment paths described above. 
				</p>
<p>The following snippet from the 
					<a class="link" href="gmf_integration.html" title="Integration with GMF Editors">GMF Example</a> shows how to use qualified names as fragments:   
				</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;QualifiedNameFragmentProvider&nbsp;implements&nbsp;IFragmentProvider&nbsp;{<br>

<br>
&nbsp;&nbsp;@Inject<br>
&nbsp;&nbsp;private&nbsp;IQualifiedNameProvider&nbsp;qualifiedNameProvider;<br>

<br>
&nbsp;&nbsp;public&nbsp;String&nbsp;getFragment(EObject&nbsp;obj,&nbsp;Fallback&nbsp;fallback)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;qualifiedName&nbsp;=&nbsp;qualifiedNameProvider.getQualifiedName(obj);<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;qualifiedName&nbsp;!=&nbsp;null&nbsp;?&nbsp;qualifiedName&nbsp;:&nbsp;fallback.getFragment(obj);<br>
&nbsp;&nbsp;}<br>

<br>
&nbsp;&nbsp;public&nbsp;EObject&nbsp;getEObject(Resource&nbsp;resource,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;fragment,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fallback&nbsp;fallback)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fragment&nbsp;!=&nbsp;null)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&lt;EObject&gt;&nbsp;i&nbsp;=&nbsp;EcoreUtil.getAllContents(resource,&nbsp;false);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(i.hasNext())&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EObject&nbsp;eObject&nbsp;=&nbsp;i.next();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;candidateFragment&nbsp;=&nbsp;(eObject.eIsProxy())&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;((InternalEObject)&nbsp;eObject).eProxyURI().fragment()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;getFragment(eObject,&nbsp;fallback);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fragment.equals(candidateFragment))&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;eObject;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;fallback.getEObject(fragment);<br>
&nbsp;&nbsp;}<br>
}<br>

<br>

</code>
</p>
</div>
<p>For performance reasons it is usually a good idea to navigate the resource based on the fragment 
					information instead of traversing it completely. If you know that your fragment is computed from 
					qualified names and your model contains something like 
					<span class="emphasis"><em>NamedElements</em></span>, you should split your fragment
					into those parts and query the root elements, the children of the best match and so on.
				</p>
<p>Furthermore it&rsquo;s a good idea to have some kind of conflict resolution strategy to be able to distinguish
					between equally named elements that actually are different, e.g. properties may have the very same qualified
					name as entities. </p>
</div>
</body>
</html>
