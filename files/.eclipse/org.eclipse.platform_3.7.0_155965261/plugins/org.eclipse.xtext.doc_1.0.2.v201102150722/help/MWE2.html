<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>MWE2</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator">
<link rel="home" href="index.html" title="Xtext User Guide">
<link rel="up" href="index.html" title="Xtext User Guide">
<link rel="prev" href="encoding.html" title="Encoding in Xtext">
<link rel="next" href="MWE2LanguageReference.html" title="Language Reference">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">MWE2</h1>
<p>The Modeling Workflow Engine 2 (MWE2) is a rewritten backwards 
			compatible implementation of the Modeling Workflow Engine (MWE). It 
			is a declarative, externally configurable generator engine. Users 
			can describe arbitrary object compositions by means of a simple, 
			concise syntax that allows to declare object instances, attribute 
			values and references. One use case &ndash; that&rsquo;s where the name had its 
			origins &ndash; is the definition of workflows. Such a workflow consists 
			usually of a number of components that interact with each other. 
			There are components to read EMF resources, to perform 
			operations (transformations) on them and to write them back or to generate 
			any number of other artifacts out of the information. Workflows are 
			typically executed in a single JVM. However there are no constraints 
			the prevent implementors to provide components that spawn multiple 
			threads or new processes.</p>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both">
<a name="MWE2Exampe"></a>Examples</h2>
</div>
</div>
</div>
<p>Let&rsquo;s start with a couple of examples to demonstrate some usage 
				scenarios for MWE2. The first examples is a simple 
				<span class="emphasis"><em>HelloWorld</em></span> 
				module that does nothing but print a message to standard out. The 
				second module is assembled of three components that read an Ecore 
				file, transform the contained classifier-names to upper-case and 
				serialize the resource back to a new file. The last examples uses 
				the life-cycle methods to print the execution time of the workflow.
			</p>
<div class="section" title="The Simplest Workflow">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="MWE2HelloWorld"></a>The Simplest Workflow</h3>
</div>
</div>
</div>
<p>The arguably shortest MWE2 module may look like the following 
					snippet.</p>
<div class="literallayout">
<p>
<code class="code">module&nbsp;HelloWorld&nbsp;<br>

<br>
SayHello&nbsp;{<br>
&nbsp;&nbsp;message&nbsp;=&nbsp;"Hello&nbsp;World!"<br>
}<br>

</code>
</p>
</div>
<p>It configures a very simple workflow component with a message 
					that should be printed to 
					<span class="emphasis"><em>System.out</em></span> when the workflow is 
					executed. The module begins with a declaration of its name. It must 
					fulfill the Java conventions for fully qualified class-names. That&rsquo;s 
					why the module 
					<span class="emphasis"><em>HelloWorld</em></span> has to be placed into the default 
					package of a Java source folder. The second element in the module is 
					the class-name 
					<span class="emphasis"><em>SayHello</em></span> which introduces the root element of the 
					module. The interpreter will create an instance of the given 
					type and configure it as declared between the curly braces. E.g. the 
					assignment 
					<span class="emphasis"><em>message = "Hello World!"</em></span> in the module will be 
					interpreted as an invocation of the 
					<span class="emphasis"><em>setMessage(String)</em></span> on the 
					instantiated object. As one can easily imagine, the implementation 
					of the class 
					<span class="emphasis"><em>SayHello</em></span> looks straight forward:
				</p>
<div class="literallayout">
<p>
<code class="code">import&nbsp;org.eclipse.emf.mwe2.runtime.workflow.IWorkflowComponent;<br>
import&nbsp;org.eclipse.emf.mwe2.runtime.workflow.IWorkflowContext;<br>

<br>
public&nbsp;class&nbsp;SayHello&nbsp;implements&nbsp;IWorkflowComponent&nbsp;{<br>

<br>
&nbsp;&nbsp;private&nbsp;String&nbsp;message&nbsp;=&nbsp;"Hello&nbsp;World!";<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;setMessage(String&nbsp;message)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this.message&nbsp;=&nbsp;message;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;public&nbsp;String&nbsp;getMessage()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;message;<br>
&nbsp;&nbsp;}<br>

<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;invoke(IWorkflowContext&nbsp;ctx)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(getMessage());<br>
&nbsp;&nbsp;}<br>

<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;postInvoke()&nbsp;{}<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;preInvoke()&nbsp;{}<br>
}<br>

</code>
</p>
</div>
<p>It looks like a simple POJO and that&rsquo;s the philosophy behind MWE2. 
					It is easily possible to assemble completely independent objects in 
					a declarative manner. To make the workflow executable with the 

					<span class="emphasis"><em>WorkflowRunner</em></span>, the component 
					<span class="emphasis"><em>SayHello</em></span> must be nested in a root 
					workflow:
				</p>
<div class="literallayout">
<p>
<code class="code">module&nbsp;HelloWorld&nbsp;<br>

<br>
Workflow&nbsp;{<br>
	component&nbsp;=&nbsp;SayHello&nbsp;{<br>
		message&nbsp;=&nbsp;"Hello&nbsp;World!"<br>
	}<br>
}<br>

</code>
</p>
</div>
<p>The class 
					<span class="emphasis"><em>Workflow</em></span> is actually 

					<span class="emphasis"><em>org.eclipse.emf.mwe2.runtime.workflow.Workflow</em></span> but its package is 
					implicitly imported in MWE2 modules to make the the modules more 
					concise. The execution result of this workflow will be revealed 
					after a quick 
					<span class="emphasis"><em>Run As .. -&gt; MWE2 Workflow</em></span> in the console as 
				</p>
<div class="literallayout">
<p>
<code class="code">Hello&nbsp;World!<br>

</code>
</p>
</div>
</div>
<div class="section" title="A Simple Transformation">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="MWE2SimpleTransformation"></a>A Simple Transformation</h3>
</div>
</div>
</div>
<p>The following workflow solves the exemplary task to rename every 
					<span class="emphasis"><em>EClassifier</em></span> in an 
					<span class="emphasis"><em>*.ecore</em></span> file.
					It consists of three components that read, modify and write the model file:
				</p>
<div class="literallayout">
<p>
<code class="code">module&nbsp;Renamer<br>
Workflow&nbsp;{<br>
&nbsp;&nbsp;component&nbsp;=&nbsp;ResourceReader&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uri&nbsp;=&nbsp;"model.ecore"<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;component&nbsp;=&nbsp;RenamingTransformer&nbsp;{}<br>
&nbsp;&nbsp;component&nbsp;=&nbsp;ResourceWriter&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uri&nbsp;=&nbsp;"uppercaseModel.ecore"<br>
&nbsp;&nbsp;}<br>
}<br>

</code>
</p>
</div>
<p>The implementation of these components is surprisingly simple. It is easily possible to create
					own components even for minor operations to automate a process.</p>
<p>The 
					<span class="emphasis"><em>ResourceReader</em></span> simply reads the file with the given 
					<span class="emphasis"><em>URI</em></span> and stores it in a so called

					<span class="emphasis"><em>slot</em></span> of the workflow context. A slot can be understood as a dictionary or map-entry.
				</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;class&nbsp;ResourceReader&nbsp;extends&nbsp;WorkflowComponentWithSlot&nbsp;{<br>
&nbsp;&nbsp;private&nbsp;String&nbsp;uri;<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;invoke(IWorkflowContext&nbsp;ctx)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;ResourceSet&nbsp;resourceSet&nbsp;=&nbsp;new&nbsp;ResourceSetImpl();<br>
&nbsp;&nbsp;&nbsp;&nbsp;URI&nbsp;fileURI&nbsp;=&nbsp;URI.createFileURI(uri);&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Resource&nbsp;resource&nbsp;=&nbsp;resourceSet.getResource(fileURI,&nbsp;true);<br>
&nbsp;&nbsp;&nbsp;&nbsp;ctx.put(getSlot(),&nbsp;resource);<br>
&nbsp;&nbsp;}<br>
	
<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;setUri(String&nbsp;uri)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this.uri&nbsp;=&nbsp;uri;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;public&nbsp;String&nbsp;getUri()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;uri;<br>
&nbsp;&nbsp;}<br>
}<br>

</code>
</p>
</div>
<p>The actual transformer takes the model from the slot and modifies it. It simply iterates the content
					of the resource, identifies each 
					<span class="emphasis"><em>EClassifier</em></span> and sets its name. 
				</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;class&nbsp;RenamingTransformer&nbsp;extends&nbsp;WorkflowComponentWithSlot&nbsp;{<br>
&nbsp;&nbsp;private&nbsp;boolean&nbsp;toLowerCase&nbsp;=&nbsp;false;<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;invoke(IWorkflowContext&nbsp;ctx)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;Resource&nbsp;resource&nbsp;=&nbsp;(Resource)&nbsp;ctx.get(getSlot());<br>
&nbsp;&nbsp;&nbsp;&nbsp;EcoreUtil.resolveAll(resource);<br>
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&lt;Object&gt;&nbsp;contents&nbsp;=&nbsp;EcoreUtil.getAllContents(resource,&nbsp;true);<br>
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&lt;EClassifier&gt;&nbsp;iter&nbsp;=&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterators.filter(contents,&nbsp;EClassifier.class);<br>
&nbsp;&nbsp;&nbsp;&nbsp;while(iter.hasNext())&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EClassifier&nbsp;classifier&nbsp;=&nbsp;(EClassifier)&nbsp;iter.next();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;classifier.setName(isToLowerCase()&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;classifier.getName().toLowerCase()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;classifier.getName().toUpperCase());<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>

<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;setToLowerCase(boolean&nbsp;toLowerCase)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this.toLowerCase&nbsp;=&nbsp;toLowerCase;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;public&nbsp;boolean&nbsp;isToLowerCase()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;toLowerCase;<br>
&nbsp;&nbsp;}<br>
}<br>

</code>
</p>
</div>
<p>After the model has been modified it should be written to a new file. That&rsquo;s what the 

					<span class="emphasis"><em>ResourceWriter</em></span> does. It actually takes the resource from the given 
					<span class="emphasis"><em>slot</em></span> and saves it with
					the configured 
					<span class="emphasis"><em>URI</em></span>:
				</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;class&nbsp;ResourceWriter&nbsp;extends&nbsp;WorkflowComponentWithSlot&nbsp;{<br>
&nbsp;&nbsp;private&nbsp;String&nbsp;uri;<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;invoke(IWorkflowContext&nbsp;ctx)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;Resource&nbsp;resource&nbsp;=&nbsp;(Resource)&nbsp;ctx.get(getSlot());<br>
&nbsp;&nbsp;&nbsp;&nbsp;URI&nbsp;uri&nbsp;=&nbsp;URI.createFileURI(getUri());<br>
&nbsp;&nbsp;&nbsp;&nbsp;uri&nbsp;=&nbsp;resource.getResourceSet().getURIConverter().normalize(uri);<br>
&nbsp;&nbsp;&nbsp;&nbsp;resource.setURI(uri);<br>
&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resource.save(null);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(IOException&nbsp;e)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;WrappedException(e);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>

<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;setUri(String&nbsp;uri)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this.uri&nbsp;=&nbsp;uri;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;public&nbsp;String&nbsp;getUri()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;uri;<br>
&nbsp;&nbsp;}<br>
}<br>

</code>
</p>
</div>
<p>Last but not least, the common super-type for those components looks like this:</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;abstract&nbsp;class&nbsp;WorkflowComponentWithSlot&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;implements&nbsp;IWorkflowComponent&nbsp;{<br>
&nbsp;&nbsp;private&nbsp;String&nbsp;slot&nbsp;=&nbsp;"model";<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;setSlot(String&nbsp;slot)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this.slot&nbsp;=&nbsp;slot;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;public&nbsp;String&nbsp;getSlot()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;slot;<br>
&nbsp;&nbsp;}<br>
	
<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;postInvoke()&nbsp;{}<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;preInvoke()&nbsp;{}<br>
}<br>

</code>
</p>
</div>
<p>Each of the mentioned implementations is rather simple and can be done in a couple of minutes. 
					This is true for many tedious tasks that developers face in their daily work. MWE2 can be used to
					automize these tasks with minimum effort.</p>
</div>
<div class="section" title="A Stopwatch">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="MWE2Stopwatch"></a>A Stopwatch</h3>
</div>
</div>
</div>
<p>The last example demonstrates how to combine the MWE2 concepts to create a simple stopwatch that
					allows to measure the execution time of a set of components. The idea is to add the very same stopwatch
					twice as a component to a workflow. It will measure the time from the first pre-invoke to the last
					post-invoke event and print the elapsed milliseconds to the console.</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;class&nbsp;StopWatch&nbsp;implements&nbsp;IWorkflowComponent&nbsp;{<br>
&nbsp;&nbsp;private&nbsp;long&nbsp;start;<br>
&nbsp;&nbsp;private&nbsp;boolean&nbsp;shouldStop&nbsp;=&nbsp;false;<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;invoke(IWorkflowContext&nbsp;ctx)&nbsp;{}<br>

<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;postInvoke()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(shouldStop)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;elapsed&nbsp;=&nbsp;System.currentTimeMillis()&nbsp;-&nbsp;start;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Time&nbsp;elapsed:&nbsp;"&nbsp;+&nbsp;elapsed&nbsp;+&nbsp;"&nbsp;ms");<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;shouldStop&nbsp;=&nbsp;true;<br>
&nbsp;&nbsp;}<br>

<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;preInvoke()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;start&nbsp;=&nbsp;System.currentTimeMillis();<br>
&nbsp;&nbsp;}<br>
}<br>

</code>
</p>
</div>
<p>Clients who want to leverage this kind of stopwatch may use the following pattern. The stopwatch-instance 
					will be added as the first component and the last component to a workflow. Everything in between will
					be measured. In this case, it is another workflow that does not need know about this decoration. The idea
					is to use a local identifier for the instantiated 
					<span class="emphasis"><em>StopWatch</em></span> and reuse this one at the end to receive
					the post-invoke life-cycle event twice. 
				</p>
<div class="literallayout">
<p>
<code class="code">module&nbsp;MeasuredWorkflow<br>

<br>
Workflow&nbsp;{<br>
&nbsp;&nbsp;component&nbsp;=&nbsp;StopWatch:&nbsp;stopWatch&nbsp;{}<br>
&nbsp;&nbsp;component&nbsp;=&nbsp;@OtherWorkflow&nbsp;{}<br>
&nbsp;&nbsp;component&nbsp;=&nbsp;stopWatch<br>
}<br>

<br>

</code>
</p>
</div>
</div>
</div>
</body>
</html>
