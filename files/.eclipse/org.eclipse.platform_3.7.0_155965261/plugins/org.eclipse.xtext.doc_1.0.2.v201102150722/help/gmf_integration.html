<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Integration with GMF Editors</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator">
<link rel="home" href="index.html" title="Xtext User Guide">
<link rel="up" href="emf_integration.html" title="Integration with EMF and Other EMF Editors">
<link rel="prev" href="xtext_resource.html" title="XtextResource Implementation">
<link rel="next" href="migrating_from_0_7.html" title="Migrating from Xtext 0.7.x to 1.0">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Integration with GMF Editors</h1>
<p>The 
				<a class="ulink" href="http://www.eclipse.org/modeling/gmp/?project=gmf" target="_new">Graphical Modeling Framework (GMF)</a> allows to create graphical diagram editors for Ecore models. To illustrate how to build a GMF on top of an 
				<span class="emphasis"><em>XtextResource</em></span> we have provided an example. You must have the Helios version 2.3 of GMF Notation, Runtime and Tooling and their dependencies installed in your workbench to run the example. With other versions of GMF it might work to regenerate the diagram code. Choose 
				<span class="emphasis"><em>New-&gt;Examples-&gt;Xtext-&gt;Xtext GMF Integration</em></span> to import it into your workbench. The example consists of a number of plug-ins
			</p>
<table id="N122E7">
<tr>
					
<td>Plug-in</td>
					<td>Framework</td>
					<td>Purpose</td>
					<td>Contents</td>
				
</tr>
<tr>
					
<td>o.e.x.example.gmf</td>
					<td>Xtext</td>
					<td>Xtext runtime plug-in</td>
					<td>Grammar, derived metamodel and language infrastructure</td>
				
</tr>
<tr>
					
<td>o.e.x.e.g.ui</td>
					<td>Xtext</td>
					<td>Xtext UI plug-in</td>
					<td>Xtext editor and services</td>
				
</tr>
<tr>
					
<td>o.e.x.e.g.edit</td>
					<td>EMF</td>
					<td>EMF.edit plug-in</td>
					<td>UI services generated from the metamodel</td>
				
</tr>
<tr>
					
<td>o.e.x.e.g.models</td>
					<td>GMF</td>
					<td>GMF design models</td>
					<td>Input for the GMF code generator</td>
				
</tr>
<tr>
					
<td>o.e.x.e.g.diagram</td>
					<td>GMF</td>
					<td>GMF diagram editor</td>
					<td>Purely generated from the GMF design models</td>
				
</tr>
<tr>
					
<td>o.e.x.e.g.d.extensions</td>
					<td>GMF and Xtext</td>
					<td>GMF diagram editor extensions</td>
					<td>Manual extensions to the generated GMF editor for integration with Xtext</td>
				
</tr>
<tr>
					
<td>o.e.x.gmf.glue</td>
					<td>Xtext and GMF</td>
					<td>Glue code</td>
					<td>Generic code to integrate Xtext and GMF</td>
				
</tr>
</table>
<p>We will elaborate the example in three stages.</p>
<div class="section" title="Stage 1: Make GMF Read and Write the Semantic Model As Text">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="gmf_integration_stage_1"></a>Stage 1: Make GMF Read and Write the Semantic Model As Text</h3>
</div>
</div>
</div>
<p>A diagram editor in GMF by default manages two resources: One for the semantic model, that is the model we&rsquo;re actually interested in for further processing. In our example it is a model representing entities and datatypes. The second resource holds the notation model. It represents the shapes you see in the diagram and their graphical properties. Notation elements reference their semantic counterparts. An entity&rsquo;s name would be in the semantic model, while the font to draw it in the diagram would be stored the notation model. Note that in the integration example we&rsquo;re only trying to represent the semantic resource as text.</p>
<p>To keep the semantic model and the diagram model in sync, GMF uses a so called 
					<span class="emphasis"><em>CanonicalEditPolicy</em></span>. This component registers as a listener to the semantic model and automatically updates diagram elements when their semantic counterparts change, are added or are removed. Some notational information can be derived from the semantic model by some default mapping, but usually there is a lot of graphical stuff that the user wants to change to make the diagram look better.   
				</p>
<p>In an Xtext editor, changes in the text are transfered to the underlying 
					<span class="emphasis"><em>XtextResource</em></span> by a call to the method 
					<span class="emphasis"><em>org.eclipse.xtext.resource.XtextResource.update(int, int, String)</em></span>, which will trigger a partial parsing of the dirty text region and a replacement of the corresponding subtree in the AST model (semantic model). 
				</p>
<p>Having an Xtext editor and a canonical GMF editor on the same resource can therefore lead to loss of notational information, as a change in the Xtext editor will remove a subtree in the AST, causing the  
					<span class="emphasis"><em>CanonicalEditPolicy</em></span> to remove all notational elements, even though it was customized by the user. The Xtext rebuilds the AST and the notation model is restored using the default mapping. It is therefore not recommended to let an Xtext editor and a canonical GMF editor work on the same resource.    
				</p>
<p>In this example, we let each editor use its own memory instance of the model and synchronize on file changes only. Both frameworks already synchronize with external changes to the edited files out-of-the-box. In the glue code, a 
					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.gmf.glue/src/org/eclipse/xtext/gmf/glue/concurrency/ConcurrentModificationObserver.java?root=Modeling_Project&view=co" target="_new">ConcurrentModificationObserver</a> warns the user if she tries to edit the same file with two different model editors concurrently.
				</p>
<p>In the example, we started with writing an Xtext grammar for an entity language. As explained above, we preferred optional assignments and rather covered mandatory attributes in a validator. Into the bargain, we added some services to improve the EMF integration, namely a formatter, a fragment provider and an unloader. Then we let Xtext generate the language infrastructure. From the derived Ecore model and its generator model, we generated the edit plug-in (needed by GMF) and added some fancier icons. </p>
<p>From the GMF side, we followed the default procedure and created a gmfgraph model, a gmftool model and a gmfmap model referring to the Ecore model derived form the Xtext grammar. We changed some settings in the gmfgen model derived by GMF from the gmfmap model, namely to enable printing and to enable validation and validation decorators. Then we generated the diagram editor.     </p>
<p>Voil&agrave;, we now have a diagram editor that reads/writes its semantic model as text. Also note that the validator from Xtext is already integrated in the diagram editor via the menu bar. </p>
<div class="section" title="Stage 2: Calling the Xtext Parser to Parse GMF Labels">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="Stage2CallingtheXtextParsertoParseGMFLabels"></a>Stage 2: Calling the Xtext Parser to Parse GMF Labels</h4>
</div>
</div>
</div>
<p>GMF&rsquo;s generated parser for the labels is a bit poor: It will work on attributes only, and will fail for cross-references, e.g. an attibute&rsquo;s type. So why not use the Xtext parser to process the user&rsquo;s input? </p>
<p>An 
						<span class="emphasis"><em>XtextResource</em></span> keeps track of it&rsquo;s concrete syntax representation by means of a so called node model (see :#parser_rules for a more detailed description). The node model represents the parse tree and provides information on the offset, length and text that has been parsed to create a semantic model element. The nodes are attached to their semantic elements by means of a node adapter.    
					</p>
<p>We can use the node adapter to access the text block that represents an attribute, and call the Xtext parser to parse the user input. The example code is contained in  
						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.gmf.glue/src/org/eclipse/xtext/gmf/glue/edit/part/AntlrParserWrapper.java?root=Modeling_Project&view=co" target="_new">AntlrParserWrapper</a>. 
						<span class="emphasis"><em>SimplePropertyWrapperEditPartOverride</em></span> shows how this is integrated into the generated GMF editor. Use the 
						<span class="emphasis"><em>EntitiesEditPartFactoryOverride</em></span> to instantiate it and the 
						<span class="emphasis"><em>EntitiesEditPartProviderOverride</em></span> to create the overridden factory, and register the latter to the extension point. Note that this is a non-invasive way to extend generated GMF editors.
					</p>
<p>When you test the editor, you will note that the node model will be corrupt after editing a few labels. This is because the node model is only updated by the Xtext parser and not by the serializer. So we need a way to automatically call the (partial) parser every time the semantic model is changed. You will find the required classes in the package 
						<span class="emphasis"><em>org.eclipse.xtext.gmf.glue.editingdomain</em></span>. To activate node model reconciling, you have to add a line 
					</p>
<div class="literallayout">
<p>
<code class="code">XtextNodeModelReconciler.adapt(editingDomain);<br>

<br>

</code>
</p>
</div>
<p>in the method 
						<span class="emphasis"><em>createEditingDomain()</em></span> of the generated 
						<span class="emphasis"><em>EntitiesDocumentProvider</em></span>. To avoid changing the generated code, you can modify the code generation template for that class by setting
					</p>
<div class="literallayout">
<p>
<code class="code">Dynamic&nbsp;Templates&nbsp;-&gt;&nbsp;true<br>
	&nbsp;&nbsp;&nbsp;Template&nbsp;Directory&nbsp;-&gt;&nbsp;"org.eclipse.xtext.example.gmf.models/templates"<br>
	&nbsp;&nbsp;&nbsp;<br>

</code>
</p>
</div>
<p>in the 
						<span class="emphasis"><em>GenEditorGenerator</em></span> and 
					</p>
<div class="literallayout">
<p>
<code class="code">Required&nbsp;Plugins&nbsp;-&gt;&nbsp;"org.eclipse.xtext.gmf.glue"&nbsp;<br>

<br>

</code>
</p>
</div>
<p>in the 
						<span class="emphasis"><em>GenPlugin</em></span> element of the gmfgen before generating the diagram editor anew.
					</p>
</div>
<div class="section" title="Stage 3: A Popup Xtext Editor (experimental)">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="Stage3APopupXtextEditorexperimental"></a>Stage 3: A Popup Xtext Editor (experimental)</h4>
</div>
</div>
</div>
<p>
						
<span class="emphasis"><em>SimplePropertyPopupXtextEditorEditPartOverride</em></span> demonstrates how to spawn an Xtext editor to edit a model element. The editor pops up in its control and shows only the section of the selected element. It is a fully fledged Xtext editor, with support of validation, code assist and syntax highlighting. The edited text is only transfered back to the model if it does not have any errors.   
					</p>
<p>Note that there still are synchronization issues, that&rsquo;s why we keep this one marked as experimental.</p>
</div>
</div>
</body>
</html>
